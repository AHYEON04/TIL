# this

### 자바스크립트에서 this 란 

현재 함수를 부른 객체가 누구인지 나타내고, 함수가 어떻게 호출되냐에 따라 this가 결정됨.  

### 1. 일반 함수 실행 방식(Regulat Function Call)

```javascript
function foo () {
console.log(this);
}
foo();
```

첫 번째로, 일반함수 실행 방식으로 함수를 실행했을 때 this의 값은 Global Object를 가리킴. 즉, 브라우저 상에서는 `window 객체`를 말함. 일반 함수 실행 방식이란 우리가 함수를 선언한 후 실행할 때 흔히 사용하는 방식을 말함.

```javascript
var name = 'Julia';
function foo () {
console.log(this.name); // 'Julia'
}
foo();
```

전역 변수로 name이란 변수를 만들고 'Julia'라는 값을 할당하였다. 이 변수는 전역 변수이기 때문에 전역 객체인 window에 속성으로 추가된다. 즉, 우리가 var name = 'Julia';라는 코드를 쓰면 window객체에 name이라는 key와 'Julia'라는 value가 추가된다.

 그리고  foo라는 함수를 선언하였고 일반 함수 실행 방식으로 실행하였다. 이 때의 this는 window객체를 가리키므로 위 코드의 **console.log(this.name);**는 **console.log(window.name);**이므로 위 코드를 실행시키면 console창에는 'Julia'가 출력된다.

```javascript

var age = 100;
function foo () {
var age = 99;
bar(age)
}
function bar () {
console.log(this.age);
}
foo();

```

이 코드에서 foo 함수 안에 bar 함수가 실행되고 있는 데, bar 함수는 this.age를 콘솔창에 출력한다. 이 때, bar함수를 잘 보면 foo 함수 내부에서 일반 함수 실행 방식으로 실행되고 있다. 그러므로  bar함수에 매개변수로 무엇을 넘겨주었든, bar 함수 내부의 this.age는 window.age를 가리키고, 이는 전역 변수로 선언된 age 변수의 값을 말한다. 그러므로 위 코드를 실행하면 99가 아닌 100이 출력된다.

### **2. 도트 표기법 (Dot Notation)**

Dot Notation이란 우리가 Object를 만들고 그 Object의 key와 value를 부여한 후 도트(.)로 값에 접근하는 방식

 

```javascript
var age = 100;
 
var ken = {
  age: 35,
  foo: function () {
    console.log(this.age);	// 35
  }
}
ken.foo();
```

 

 ken이라는 변수에 Object를 만들었는데 foo라는 key에 this.age를 출력하도록 함수를 만들고 우리는 ken.foo();라고 함수를 실행하고 있는 데, 이렇게 도트를 사용하여 객체 속성의 값에 접근하는 방식을 Dot Notation이라고 한다. 

 그리고 이렇게 Dot Notation으로 함수가 실행되면, this는 그 **도트 앞에 써있는 객체 자체**를 가리킨다. 즉, 위 코드에서 this.age의 this는 ken을 가리킨다. 그러므로 this.age는 ken.age와 같기 때문에 35가 출력된다.



```javascript
function foo() {
  console.log(this.age);
}
var age = 100;
var ken = {
  age: 36,
  foo: foo
}
var wan = {
  age: 32,
  foo: foo
}
ken.foo();  // 36
wan.foo();  // 32
 
var fn = ken.foo;
fn();	// 100
```

  foo라는 함수에는 this.age를 출력하는 실행문이 들어있다. 그리고 전역 변수 age가 선언되어 100이라는 값이 할당되었다. 그리고 ken이라는 객체가 선언되어, age와 foo라는 key를 부여하였는 데, 여기서 foo의 value는 함수 foo의 이름이다. wan이란객체도 동일하다

 이 상황에서 ken.foo();라고 함수를 실행하면 이 때의 foo 함수는 Dot Notation 방식으로 실행되었기 때문에, this는 ken 객체 자체를 가리키게 되고 36이란 값이 출력된다. wan.foo();도 마찬가지이다. 그러나 아래 fn변수를 보자. fn이란 변수에 우리는 ken.foo라는 값을 입력하고 fn();라고 실행하였다. 이는 즉, 함수를 Dot notation이 아니고 일반 실행 함수 방식으로 실행한 것이다. 그러므로 이 때의 this는 Global Object를 가리키게 되고 전역 변수 age의 값인 100이 출력된다.

 

 

 

### **3. 명백한 바인딩 (Explicit Binding) / call, bind, apply**

명백한 바인딩, 즉 this의 역할을 우리가 직접 명확하게 지정해준다는뜻으로 이는 **function.prototype.call, function.prototype.bind, function.prototype.apply**과 같은 메소드를 사용하여 할 수 있다.

 

```javascript
var age = 100;
function foo() {
  console.log(this.age);
}
var ken = {
  age: 35,
  log: foo
}
 
foo.call(ken, 1, 2, 3);
```

 

위 코드에서  foo 함수에 call 메소드를 사용하여 실행하였는 데, 인자로 각각 ken, 1, 2, 3을 주었다. 이 인자들 중에서 가장 첫 번째로 쓴 ken이 바로 this의 값으로 지정되고1, 2, 3은 this의 값과는 상관없이 순서대로 foo 함수가 된다. 그러므로 위 코드에서 this.age는 ken.age가 되어 35가 출력된다.

 

 

```javascript
var age = 100;
function foo() {
  console.log(this.age);
}
var ken = {
  age: 35,
  log: foo
}
 
foo.apply(ken, [1, 2, 3, 4, 5]);
```

 

위 코드에서 apply또한 같은 역할을 한다. apply는 this의 값을 지정해주는 인자 외에도 배열을 인자로 넣을 수 있는 데, 이 배열의 값이 순차적으로 foo 함수의 인자가 된다.

 

 

 

### **4. new 키워드를 사용한 함수 실행**

 함수를 그냥 foo()와 같은 형태로 실행할 수도 있지만 new 키워드를 사용해서 생성자 함수로 만들어 사용할 수도 있다. 이 경우에 this는 **빈 객체**가 된다.

 

```javascript
function Person () {
  console.log(this);
}
 
new Person();
```

 

즉 위 코드에서 우리는 Person이라는 함수를 선언하였고, new Person(); 즉, new 키워드를 사용하여 Person 함수를 생성자 함수로 사용하였다. 이 때, this는 빈 객체를 가리키며 위의 생성자 함수는 this라는 빈 객체를 return한다. (심지어 return문이 없더라도 말이다. 이는 생성자 함수의 특징 중 하나이다.)

 

 

```javascript
function Foo () {
  console.log(this.age);  // undefined
  this.age = 100; // 빈 객체에 속성 추가
  console.log(this.age);  // 100
}
 
new Foo();
```

 

위 코드에서 Foo 함수가 new 키워드와 함께 생성자 함수로 사용되는 즉시, 함수 내부의 this는 빈 객체가 되며, this.age = 100; 이라는 코드를 통해, 그 빈 객체에 age라는 속성을 추가하고 100이란 값을 할당하게 된다. 그러므로 4번째 줄에서 this.age는 100을 출력한다. 그리고 Foo 함수는 **{ age: 100 }**이라는 객체를 리턴한다.

 

 

```javascript
function Person () {
  this.name = 'ken';
  console.log(this);
}
 
var ken = new Person();
console.log(ken);
```

 

위 코드를 보면. Person이라는 함수가 있고, this.name = 'ken';이라는 구문이 있는데 만약에 위 코드가 일반 함수 실행 방식으로 실행되었다면, this는 window를 가리키게 될 것이고 window 객체에 name이란 속성과 'ken'이란 값이 추가된다. 그리고 위 코드는 return문이 없기 때문에 어떠한 값도 리턴하지 않으므로 ken이란 변수엔 어떤 것도 할당되지 않아 console창에는 undefined가 출력된다.

 그러나 위 함수는 new Person(); 즉, 생성자 함수로 실행되어 this는 빈 객체를 생성하여 name이란 속성과 'ken'이란 값을 할당하고 return문이 없음에도 불구하고 그 객체가 리턴된다. 그러므로 ken이란 변수에는 **{ name: "ken" }** 이라는 객체가 할당되어 console.log에는 그 객체가 return된다.

 

```javascript
function foo () {
  this.age = 100;
  return 3;
}
var a = new foo();
console.log(a);
```

생성자 함수는  return문이 있음에도 불구하고 그 return문을 무시하고 this 객체를 return하는 특징이 있어서 위의 코드에서 일반적인 상식으로는 3이 리턴되어야 하지만 생성자 함수로 사용되었기 때문에 **{ age: 100 }**이 return된다.

 

```
function foo () {
  this.age = 100;
  return { haha: 23232 };
}
var a = new foo();
console.log(a);
```

 그러나 생성자 함수도 리턴되는 대상이 객체라면 this객체 대신에 해당 객체가 리턴된다. 즉, 위에서 a는 { age: 100 }이 아닌 { haha: 23232 }가 된다.

 





 
