## 기본 문법 복습



#### Callback과 non-block

   콜백함수를 쓰는 이유는 비동기 작업때문인데 어떤 작업을 진행시켜두고 함수 내에서 작업을 처리하여 완료 되었을 때 전달받은 콜백함수를 호출하여 기능을 처리합니다.

  즉,  callback함수란 대부분 비동기 프로그래밍 방식으로 코드를 만들 때 쓰이는데, 예를들어 어떤 함수를 실행한 후 결과 값이 반환될 때까지 기다리지 않고 바로 그 다음 코드를 실행하려면 비동기 방식으로 코드를 만들어야 합니다. 즉,  함수를 시행하는데 시간이 걸릴 수 있기 때문에 그 다음 코드를 바로 실행합니다. 그리고 연산이 끝났을 때 파라미터로 전달한 함수가 실행될 수 있다면 그 시점에 결과를 처리할 수 있는 효율적인 프로그램을 만들 수 있는데 이 때 **파라미터로 전달되는 함수를 콜백함수(Callback Function)**이라고 합니다.



*예시*

```javascript
function add(a, b, callback){
   var result = a + b;
   callback(result);
}

add( 1, 2, function(result){
  console.log(result);
});
```



**Non-Blocking**은  Blocking 방식의 비효율성을 극복하고자 만들어졌는데, Non- Blocking은  I/O 작업을 진행하는 동안 유저 프로세스의 작업을 중단시키지 않음. 유저 프로세스가 커널에게 I/O를 요청하는 함수를 호출하면, 함수는 *I/O를 요청한 다음 진행상황과 상관없이 바로 결과를 반환* 합니다.



#### Promise

콜백함수를 사용하여 중첩이 많이 되면 가독성도 크게 떨어지고 콜백 헬이 나타납니다. 이를 개선하기 위해 나온 방법 중 하나가 **Promise**입니다.



프로미스 규칙

- 프로미스 객체 생성

  ```javascript
  const condition = true; //true면 resolev, false면 reject
  const promise = new Promise((resolve, reject) => {
     if(condition){
           resolve('성공');
     }else{
           reject('실패');
     }
  });
  
  promise
   .then((message) => {
      console.log(message);
   })
   .catch((error) => {
      console.error(error);
   });
  ```

  new promise로 프로미스를 생성할 수 있고, 안에 resolve와 reject를 매개변수로 갖는 콜백함수에 넣어줍니다. 이렇게 만든 프로미스 변수에 then과 catch 메서드를 붙일 수 있습니다. 프로미스 내부에서 resolve가 호출되면 then이 실행되고, reject가 호출되면 catch가 실행되어 오류를 처리할 수 있습니다.

  

- **콜백을 쓰는 패턴**

  - 여러개의 비동기 작업들이 존재하고 이들이 모두 완료되었을 때 작업을 진행하고 싶다면, **Promise.All**을 활용하면 됩니다.

  ```javascript
  const promise1 = Promise.resolve('성공');
  const promise2 = Promise.resolve('성공2');
  Promise.all([promise1, promise2])
    .then((result) => {
      console.log(result); //[ '성공1', '성공2' ]
    })
    .catch((error) = >{
      console.error(error);
    })
  ```

  

  

  





*로직을 순서도로 표현했을 때*

![image-20201204190049856](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20201204190049856.png)

 참고:  https://programmingsummaries.tistory.com/325



#### 테스트 코드란

테스트 코드는 이후 다른 변경 사항으로 인해 발생 가능한 결함을 찾아내는 역할을 합니다.

**테스트 코드의 장점**

- 제품의 안정성을 높이고 기능 추가 및 수정으로 인한 부작용을 줄임
- 불안감없이 코드 작성을 할 수 있도록 도와줌
- 디버깅을 쉽게 해줌
- 개발 과정에서 반복적인 작업들을 하지 않도록 도와줌
- 더 깔끔하고 재사용성이 좋은 코드 작성을 가능하게 해줌

**테스트 코드의 기본 원칙**

테스트의 구성단위에는 단위 테스트, 통합 테스트, 승인 테스트 등 다양한 테스트가 있습니다.

**테스트의 원칙**

- 테스팅은 결함의 존재를 보여주는 것
- 완벽한 테스트는 불가능
- 테스트 구성은 가능한 빠른 시기에
- 결함은 군집되어 있음
- 살충제 역설- 비슷한 테스트가 반복되면 새로운결함을 반복할 수 없음
- 테스팅은 정황에 의존적
- 오류 부재의 오해 - 사용되지 않는 시스템이나 사용자의 기대에 부응하지 않는 기증의 결함을 찾고 수정하는 것은 의미가 없음

**단위테스트 원칙** (*F.I.R.S.T*)

단위 테스트는 가장 작은 단위의 테스트로 모든 테스트의 시작점이고, 단위 테스트만 구성되어도 많은 문제를 해결할 수 있고 코드의 품질이 훨씬 좋아질 수 잇습니다.

- *fast* - 유닛 테스트는 빨라야 한다.
- *isolated* - 다른 테스트는 종속적인 테스트는 절대로 작성하지 않는다.
- *Repeatable* - 테스트는 실행할 때마다 같은 결과를 만들어야 한다.
- *Self-validating* - 테스트는 스스로 결과물이 옳은 지 그른지 판단할 수 있어야 한다.
- *Timely* - 유닛 테스트는 프로덕션 코드가 테스트를 성공하기 직전에 구성되어야 한다.









