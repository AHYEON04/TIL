# 실행 컨텍스트

**실행컨텍스트란 자바스크립트 코드가 실행되고 연산되는 범위를 나타내는 추상적인 개념으로 코드가 실행된다면 실행 컨텍스트 내부에서 실행되고 있는 것으로 콜스택과 연관하여 정의하면, 실행 가능한 자바스크립트 코드 블록이 실행되는 환경.** 

- 현재 실행되는 컨텍스트에서 이 컨텍스트와 관련 없는 실행 코드가 실행되면, 새로운 컨텍스트가 생성되어 스택에 들어가고 제어권이 그 컨텍스트로 이동됨.
- 전역 실행 컨텍스트가 가장 먼저 실행되고 이 과정에서 새로운 함수 호출이 발생하면 새로운 컨텍스트가 만들어지고 실행되며, 종료되면 반환됨. 이와 같은 과정이 반복된 후, 전역 실행 컨텍스트의 실행이 완료되면 모든 실행이 끝남.

자바스크립트 엔진은 코드를 실행하기 위해서 실행에 필요한 정보를 알아야 한다.  실행에 필요한 것은 

- 변수: 전역변수, 지역변수, 매개 변수, 객체의 프로퍼티
- 함수 선언
- 변수의 유효범위
- this

위와 같은 정보로 실행에 필요한 정보를 형상화하고 구분하기 위해서 자바스크립트 엔진은 실행 컨텍스트를 물리적 객체의 형태로 관리함.

### Execution Stack(호출 스택)과 함수 실행 순서



#### [Types of Exection Context]

- **Global Execution Context** 

​        가장 베이스가 되는 실행구역으로 특정 '함수'안에서 실행되는 코드가             

​        아니라면 코드는 전역 컨텏트에서 실행됨. 전역 컨텍스트에서는 두가지 

​        일이 이루어 지는데 1) `window`오브젝트인 전역 컨텍스트를 생성하고

​         2) `this`를 global object로 할당함.

- **Functional Execution Context**

  함수가 호출될 때마다, 해당 함수에 대한 실행 컨텍스트가 생성됨. 각각의

  함수들은 자신만의 실행 컨텍스트를 가지지만 실행 컨텍스트는 함수가 호

  출이 되어야 만들어짐.

​        

#### [Execution Stack (호출 스택)과 함수 실행 순서]

스택은 LIFO(Last in,First out) 자료 구조로 코드가 실행하면서 만드는 실행 컨텍스트들이 저장되는 구조로 자바스크립트 엔진이 `script`tag를 처음 만나면 전역 컨텍스트를 만들고 현재 실행되고 있는 호출 스택이 이것을 push하고 다른 함수가 호출되면 해당 함수에 대한 실행 컨텍스트를 생성하고 스택의 제일 꼭대기에 push한다. 

#### [This binding]

`this`의 값이 여기서 결정되는데 글로벌 실행 컨텍스트에서 this는 global object로 함수 실행 컨텍스트에서는 `this`의 값은 어떻게 함수가 호출되었는지에 따라 달라짐. 만약 함수가 object reference로 호출되었다면 `this`는 해당 객체를 가리키게 되고 그렇지 않으면 this는 글로벌 객체를 가리키거나 strict mode에서는 `undefined`를 가리키고 있음.

```javascript
//this 함수 호출
const person = {
   name:'peter',
   birthYear: function(){
      console.log(2020-this.birthYear);
   }
}
person.calcAge();
const calcuateAge = person.calcAge;
calculateAge();
```

- `person.clacAge()`calcAge는 'person' object reference로 호출되었기 때문에 여기서 "this"는 person을 가리키게 됨.
- `calculateAge()` 여기서는 주어진 객체 참조값이 없기에 this는 글로벌 객체인 window를 가리킴.

### [클로저]

**클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경인 스코프를 기억하여 자신이 선언됐을 때의 환경 밖에서 호출되어도 그 환경에 접근할 수 있는 함수** 를 말함.  

스코프는 함수를 호출할 때가 아니라 함수를 어디에 선언하였는지에 따라 결정됨. 이를 렉시컬 스코핑이라고 함. 

```javascript
function outerFunc() {
  var x = 10;
  var innerFunc = function () { console.log(x); };
  return innerFunc
}

var inner = outerFunc();
inner(); // 10
```

위 예제의 함수 innerFunc는 함수 outerFunc의 내부에서 선언되었기 때문에 함수 innerFunc의 상위 스코프는 함수 outerFunc임. 함수 innerFunc가 전역에 선언되었다면 innerFunc의 상위 스코프는  전역 스코프가 됨.

`outerFunc()`는 내부함수 `innerFunc()`를 반환하고 실행 컨텍스트 스택에서 사라졌지만, 여전히 스코프체인에서는 `outerFunc()`의 변수 객체가 존재하고 이처럼 자신을 포함하고 있는 외부함수보다 내부함수가 더 오래유지되는 경우, 외부함수 밖에서 내부함수가 호출되더라도 외부함수의 지역 변숭에 접근할 수 있는데 이러한 함수를 클로저(closure)라고 함. 이 코드에서는 `outerFunc`에서 선언된 `x`와 같은 변수를 **자유 변수**라고 함.

**즉, 클로저는 반환된 내부함수가 자신이 선언됐을 때의 렉시컬환경인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 스코프에 접근할 수 있는 함수를 말함.** 





